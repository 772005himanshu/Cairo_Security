Cairo uses felt252 as the underlying data type for all the available types. The `felt252` type can handle values from 0 upto p -1 , where p to the big 252 bit prime number `p = 2 + 17 * 2 + 1` . All the math operation in Cairo are done modulo o: operation are done over a finit field of order p.
That means :
- adding 3 to p -1 results 2
- subtracting p -1 from 0 results 1

## Arithmetic Overflow And Overflow
Performing Direct Operation on fet252 types does not ensure checks against overflow/underflow

For Example THe function check_balance() supposed to check that callers balance is more than the amount specified in the input amt.

```rust
    struct Storage {
        balances: LegacyMap<ContractAddress, felt252>
    }

    fn check_balance(self : @ContractState, amt : felt252) {
        let caller = get_caller_address();
        let balance = self.balances.read(caller);
        assert(balance - amt >= 0);
    }
```

A good way to avoid those type of problems is to use different data types such as `u128` which internally provides underflow/ overflow checks and revert when a math operation result goes out of the allowed range of values

```rust
fn main() {
    fn overflow_u128() -> u128 {
        let max: u128 = 0xffffffffffffffffffffffffffffffff_u128; // Maximum u128 value type(u128).max
        max + 3_u128; // Adding to max overflow protection trigger if necessary
    }

    fn  underflow_u128() -> u128 {
        let max: u128 = 0_u128; // Zero value for u128 min
        min - 3_u128; // Subtracting to min Underflow protection trigger if necessary

    }
}
```


## Integer Division
- Always Mutliple before Division for protect from round-off error
- In cairo , if the number is completely divided this gives us `int` or value 
- But if it not divided completely it gives us `different value` or Whole value without the decimals so we have to handle . These cases differently
- So we have to proves that part of the code for better results